const fs=require("fs");
function cal_layout(graphlist){
    let path="D:\\zy\\projects\\kg4payoffs\\src\\assets\\"
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 800;
        let k;
        let mNodeList = [];
        let mEdgeList = [];
        let mDxMap = {};
        let mDyMap = {};
        let mNodeMap = {};
        let flag=[];
        
      
        for(let i=0;i<graphlist.length;i++){
            let line=graphlist[i];
            if(flag.indexOf(line[0])<0){
                flag.push(line[0]);
                mNodeList.push(new Node(line[0]));
            }
            if(flag.indexOf(line[1])<0){
                flag.push(line[1]);
                mNodeList.push(new Node(line[1]));
            }
            mEdgeList.push(new Edge(line[0], line[1]));
        }
        
        if(mNodeList && mEdgeList) {
            k = Math.sqrt(CANVAS_WIDTH * CANVAS_HEIGHT / mNodeList.length);
        }
        for (let i = 0; i < mNodeList.length; i++) {
            let node = mNodeList[i];
            if (node) {
              mNodeMap[node.id] = node;
            }
        }
        //随机生成坐标. Generate coordinates randomly.
        let initialX, initialY, initialSize = 40.0;
        for (let i in mNodeList) {
            initialX = CANVAS_WIDTH * .5;
            initialY = CANVAS_HEIGHT * .5;
            mNodeList[i].x = initialX + initialSize * (Math.random() - .5);
            mNodeList[i].y = initialY + initialSize * (Math.random() - .5);
        }
        for (let i = 0; i < 15; i++) {
            console.log(i)
            calculateRepulsive();
            calculateTraction();
            updateCoordinates();
        }
        console.log(mNodeList.length)
        let resultlayout=JSON.stringify(new Result(mNodeList, mEdgeList));
        fs.writeFile(path+'1.json',resultlayout,function(err){
            if (err) {res.status(500).send('Server is error...')}
        })
        //点类
        function Node(id = null) {
            this.id = id;
            this.x = 22;
            this.y = null;
        }
        //边类
        function Edge(source = null, target = null) {
            this.source = source;
            this.target = target;
        }
        /**
         * 计算两个Node的斥力产生的单位位移。
         * Calculate the displacement generated by the repulsive force between two nodes.*
         */
        function calculateRepulsive() {
            let ejectFactor = 10;
            let distX, distY, dist;
            for (let i = 0; i < mNodeList.length; i++) {
              mDxMap[mNodeList[i].id] = 0.0;
              mDyMap[mNodeList[i].id] = 0.0;
              for (let j = 0; j < mNodeList.length; j++) {
                if (i !== j) {
                  distX = mNodeList[i].x - mNodeList[j].x;
                  distY = mNodeList[i].y - mNodeList[j].y;
                  dist = Math.sqrt(distX * distX + distY * distY);
                  if(dist>=250){
                    continue;
                  }
                }
                if (dist < 80) {
                  ejectFactor = 20;
                }
                if (dist > 0 && dist < 250) {
                  let id = mNodeList[i].id;
                  mDxMap[id] = mDxMap[id] + distX / dist * k * k / dist * ejectFactor;
                  mDyMap[id] = mDyMap[id] + distY / dist * k * k / dist * ejectFactor;
                }
              }
            }
          }
      
          /**
           * 计算Edge的引力对两端Node产生的引力。
           * Calculate the traction force generated by the edge acted on the two nodes of its two ends.
           */
          function calculateTraction() {
            let condenseFactor = 300;
            let startNode, endNode;
            for (let e = 0; e < mEdgeList.length; e++) {
      
              let eStartID = mEdgeList[e].source;
              let eEndID = mEdgeList[e].target;
              //console.log(Com[eStartID],Com[eEndID])
              startNode = mNodeMap[eStartID];
              endNode = mNodeMap[eEndID];
              if (!startNode) {
                console.log("Cannot find start node id: " + eStartID + ", please check it out.");
                return;
              }
              if (!endNode) {
                console.log("Cannot find end node id: " + eEndID + ", please check it out.");
                return;
              }
      
              let distX, distY, dist;
              distX = startNode.x - endNode.x;
              distY = startNode.y - endNode.y;
              dist = Math.sqrt(distX * distX + distY * distY);
              mDxMap[eStartID] = mDxMap[eStartID] - distX * dist / k * condenseFactor;
              mDyMap[eStartID] = mDyMap[eStartID] - distY * dist / k * condenseFactor;
              mDxMap[eEndID] = mDxMap[eEndID] + distX * dist / k * condenseFactor;
              mDyMap[eEndID] = mDyMap[eEndID] + distY * dist / k * condenseFactor;
            }
          }
  
        /**
         * 更新坐标。
         * update the coordinates.
         */
        function updateCoordinates() {
            let maxt = 4, maxty = 3; //Additional coefficients.
            for (let v = 0; v < mNodeList.length; v++) {
            let node = mNodeList[v];
            let dx = parseInt(mDxMap[node.id]);
            let dy = parseInt(mDyMap[node.id]);
        
            if (dx < -maxt) dx = -maxt;
            if (dx > maxt) dx = maxt;
            if (dy < -maxty) dy = -maxty;
            if (dy > maxty) dy = maxty;
            node.x = node.x + dx >= CANVAS_WIDTH || node.x + dx <= 0 ? node.x - dx : node.x + dx;
            node.y = node.y + dy >= CANVAS_HEIGHT || node.y + dy <= 0 ? node.y - dy : node.y + dy;
            }
        }
  
        function Result(nodes = null, links = null) {
            this.nodes = nodes;
            this.links = links;
        }
          
console.log("run")
}
module.exports=cal_layout;